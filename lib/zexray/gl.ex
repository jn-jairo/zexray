defmodule Zexray.Gl do
  @moduledoc """
  Gl
  """

  alias Zexray.NIF

  #######################
  #  Matrix operations  #
  #######################

  @doc """
  Run function with matrix mode.
  """
  @doc group: :matrix_operation
  @spec with_matrix_mode(
          mode :: Zexray.Enum.MatrixMode.t(),
          mode_after :: Zexray.Enum.MatrixMode.t(),
          func :: (-> any)
        ) :: any
  def with_matrix_mode(mode, mode_after, func) when is_function(func) do
    try do
      matrix_mode(mode)
      func.()
    after
      matrix_mode(mode_after)
    end
  end

  @doc """
  Choose the current matrix to be transformed
  """
  @doc group: :matrix_operation
  @spec matrix_mode(mode :: Zexray.Enum.MatrixMode.t()) :: :ok
  defdelegate matrix_mode(mode), to: NIF, as: :rl_matrix_mode

  @doc """
  Push the current matrix, run function and pop matrix.
  """
  @doc group: :matrix_operation
  @spec with_matrix(func :: (-> any)) :: any
  def with_matrix(func) when is_function(func) do
    try do
      push_matrix()
      func.()
    after
      pop_matrix()
    end
  end

  @doc """
  Push the current matrix to stack
  """
  @doc group: :matrix_operation
  @spec push_matrix() :: :ok
  defdelegate push_matrix(), to: NIF, as: :rl_push_matrix

  @doc """
  Pop latest inserted matrix from stack
  """
  @doc group: :matrix_operation
  @spec pop_matrix() :: :ok
  defdelegate pop_matrix(), to: NIF, as: :rl_pop_matrix

  @doc """
  Reset current matrix to identity matrix
  """
  @doc group: :matrix_operation
  @spec load_identity() :: :ok
  defdelegate load_identity(), to: NIF, as: :rl_load_identity

  @doc """
  Multiply the current matrix by a translation matrix
  """
  @doc group: :matrix_operation
  @spec translate(
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate translate(
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_translate

  @doc """
  Multiply the current matrix by a rotation matrix
  """
  @doc group: :matrix_operation
  @spec rotate(
          angle :: number,
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate rotate(
                angle,
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_rotate

  @doc """
  Multiply the current matrix by a scaling matrix
  """
  @doc group: :matrix_operation
  @spec scale(
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate scale(
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_scale

  @doc """
  Multiply the current matrix by another matrix
  """
  @doc group: :matrix_operation
  @spec mult_matrix(mat :: Zexray.Type.Matrix.t_all()) :: :ok
  defdelegate mult_matrix(mat), to: NIF, as: :rl_mult_matrix

  @doc """
  Multiply the current matrix by a perspective matrix generated by parameters
  """
  @doc group: :matrix_operation
  @spec frustum(
          left :: number,
          right :: number,
          bottom :: number,
          top :: number,
          znear :: number,
          zfar :: number
        ) :: :ok
  defdelegate frustum(
                left,
                right,
                bottom,
                top,
                znear,
                zfar
              ),
              to: NIF,
              as: :rl_frustum

  @doc """
  Multiply the current matrix by an orthographic matrix generated by parameters
  """
  @doc group: :matrix_operation
  @spec ortho(
          left :: number,
          right :: number,
          bottom :: number,
          top :: number,
          znear :: number,
          zfar :: number
        ) :: :ok
  defdelegate ortho(
                left,
                right,
                bottom,
                top,
                znear,
                zfar
              ),
              to: NIF,
              as: :rl_ortho

  @doc """
  Set the viewport area
  """
  @doc group: :matrix_operation
  @spec viewport(
          x :: integer,
          y :: integer,
          width :: integer,
          height :: integer
        ) :: :ok
  defdelegate viewport(
                x,
                y,
                width,
                height
              ),
              to: NIF,
              as: :rl_viewport

  @doc """
  Set clip planes distances
  """
  @doc group: :matrix_operation
  @spec set_clip_planes(
          near_plane :: number,
          far_plane :: number
        ) :: :ok
  defdelegate set_clip_planes(
                near_plane,
                far_plane
              ),
              to: NIF,
              as: :rl_set_clip_planes

  @doc """
  Get cull plane distance near
  """
  @doc group: :matrix_operation
  @spec get_cull_distance_near() :: float
  defdelegate get_cull_distance_near(), to: NIF, as: :rl_get_cull_distance_near

  @doc """
  Get cull plane distance far
  """
  @doc group: :matrix_operation
  @spec get_cull_distance_far() :: float
  defdelegate get_cull_distance_far(), to: NIF, as: :rl_get_cull_distance_far

  #############################
  #  Vertex level operations  #
  #############################

  @doc """
  Initialize drawing mode, run function and finish vertex providing.
  """
  @doc group: :vertex_operation
  @spec with_drawing(
          mode :: Zexray.Enum.DrawMode.t(),
          func :: (-> any)
        ) :: any
  def with_drawing(mode, func) when is_function(func) do
    try do
      begin_drawing(mode)
      func.()
    after
      end_drawing()
    end
  end

  @doc """
  Initialize drawing mode (how to organize vertex)
  """
  @doc group: :vertex_operation
  @spec begin_drawing(mode :: Zexray.Enum.DrawMode.t()) :: :ok
  defdelegate begin_drawing(mode), to: NIF, as: :rl_begin

  @doc """
  Finish vertex providing
  """
  @doc group: :vertex_operation
  @spec end_drawing() :: :ok
  defdelegate end_drawing(), to: NIF, as: :rl_end

  @doc """
  Define one vertex (position) - 2 float
  """
  @doc group: :vertex_operation
  @spec vertex2(
          x :: number,
          y :: number
        ) :: :ok
  defdelegate vertex2(
                x,
                y
              ),
              to: NIF,
              as: :rl_vertex2

  @doc """
  Define one vertex (position) - 3 float
  """
  @doc group: :vertex_operation
  @spec vertex3(
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate vertex3(
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_vertex3

  @doc """
  Define one vertex (texture coordinate) - 2 float
  """
  @doc group: :vertex_operation
  @spec tex_coord2(
          x :: number,
          y :: number
        ) :: :ok
  defdelegate tex_coord2(
                x,
                y
              ),
              to: NIF,
              as: :rl_tex_coord2

  @doc """
  Define one vertex (normal) - 3 float
  """
  @doc group: :vertex_operation
  @spec normal3(
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate normal3(
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_normal3

  @doc """
  Define one vertex (color) - 4 byte
  """
  @doc group: :vertex_operation
  @spec color4_byte(
          r :: number,
          g :: number,
          b :: number,
          a :: number
        ) :: :ok
  defdelegate color4_byte(
                r,
                g,
                b,
                a
              ),
              to: NIF,
              as: :rl_color4_byte

  @doc """
  Define one vertex (color) - 3 float
  """
  @doc group: :vertex_operation
  @spec color3(
          x :: number,
          y :: number,
          z :: number
        ) :: :ok
  defdelegate color3(
                x,
                y,
                z
              ),
              to: NIF,
              as: :rl_color3

  @doc """
  Define one vertex (color) - 4 float
  """
  @doc group: :vertex_operation
  @spec color4(
          x :: number,
          y :: number,
          z :: number,
          w :: number
        ) :: :ok
  defdelegate color4(
                x,
                y,
                z,
                w
              ),
              to: NIF,
              as: :rl_color4

  #######################
  #  Render management  #
  #######################

  @doc """
  Run function with texture.
  """
  @doc group: :render_management
  @spec with_texture(
          texture :: non_neg_integer | Zexray.Type.Texture.t_all(),
          func :: (-> any)
        ) :: any
  def with_texture(texture, func) when is_function(func) do
    try do
      set_texture(texture)
      func.()
    after
      set_texture()
    end
  end

  @doc """
  Set current texture for render batch and check buffers limits
  """
  @doc group: :render_management
  @spec set_texture(texture :: non_neg_integer | Zexray.Type.Texture.t_all()) :: :ok
  defdelegate set_texture(texture \\ 0), to: NIF, as: :rl_set_texture
end
